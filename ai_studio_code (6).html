<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Parcel Master Pro v3</title>
    <script async src="https://docs.opencv.org/4.5.4/opencv.js" type="text/javascript"></script>
    <style>
        body { margin: 0; background: #000; font-family: sans-serif; overflow: hidden; color: white; }
        #container { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
        video { position: absolute; width: 100%; height: 100%; object-fit: cover; opacity: 0; }
        canvas { position: absolute; width: 100%; height: 100%; object-fit: cover; z-index: 5; }
        
        #ui-top { position: absolute; top: 0; width: 100%; z-index: 20; background: rgba(0,0,0,0.85); padding: 20px 0; text-align: center; border-bottom: 2px solid #007bff; }
        .status { font-size: 1.2rem; font-weight: bold; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; }
        .progress-bg { width: 80%; background: #333; height: 10px; margin: 0 auto; border-radius: 5px; }
        #progress-fill { width: 0%; height: 100%; background: #28a745; border-radius: 5px; transition: width 0.2s; }
        
        .controls { position: absolute; bottom: 40px; width: 100%; z-index: 20; display: flex; flex-direction: column; align-items: center; gap: 15px; }
        button { padding: 20px 50px; font-size: 1.3rem; border-radius: 50px; border: none; font-weight: bold; color: white; cursor: pointer; }
        #btn-measure { background: #007bff; width: 75%; display: none; box-shadow: 0 4px 15px rgba(0,123,255,0.4); }
        #btn-reset { background: #444; font-size: 0.9rem; padding: 12px 25px; }

        #loading { position: fixed; inset: 0; background: #111; z-index: 100; display: flex; flex-direction: column; justify-content: center; align-items: center; }
    </style>
</head>
<body>

<div id="loading">
    <div style="font-size: 3rem; margin-bottom: 15px;">ðŸ“¦</div>
    <p>KI-Modelle werden geladen...</p>
</div>

<div id="container">
    <video id="videoInput" playsinline muted></video>
    <canvas id="canvasOutput"></canvas>
</div>

<div id="ui-top">
    <div id="status">Warte auf Kamera...</div>
    <div class="progress-bg" id="p-bar-container">
        <div id="progress-fill"></div>
    </div>
</div>

<div class="controls">
    <button id="btn-measure" onclick="onMeasureClick()">PAKET VERMESSEN</button>
    <button id="btn-reset" onclick="resetCalibration()">NEU KALIBRIEREN</button>
</div>

<script>
let state = 'SCAN';
let pxPerCm = localStorage.getItem('px_cm') ? parseFloat(localStorage.getItem('px_cm')) : null;
let calibSamples = [];
const REQUIRED_SAMPLES = 40;

const video = document.getElementById('videoInput');
const canvas = document.getElementById('canvasOutput');
const ctx = canvas.getContext('2d');
const statusText = document.getElementById('status');
const btnMeasure = document.getElementById('btn-measure');
const progressFill = document.getElementById('progress-fill');

let isStreaming = false;
let lastResult = null;

function onOpenCvReady() {
    document.getElementById('loading').style.display = 'none';
    initCamera();
}

async function initCamera() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } } 
        });
        video.srcObject = stream;
        video.play();
        video.oncanplay = () => {
            if (!isStreaming) {
                isStreaming = true;
                state = pxPerCm ? 'READY' : 'SCAN';
                updateUI();
                processFrame();
            }
        };
    } catch (e) {
        alert("Kamera-Fehler");
    }
}

function updateUI() {
    if (state === 'SCAN') {
        statusText.innerText = "Phase 1: Blatt scannen";
        statusText.style.color = "#ffc107";
        btnMeasure.style.display = "none";
        document.getElementById('p-bar-container').style.display = "block";
    } else if (state === 'READY') {
        statusText.innerText = "Phase 2: Paket vermessen";
        statusText.style.color = "#00ff00";
        btnMeasure.style.display = "block";
        btnMeasure.innerText = "PAKET VERMESSEN";
        document.getElementById('p-bar-container').style.display = "none";
    } else {
        statusText.innerText = "ERGEBNIS";
        btnMeasure.innerText = "ZURÃœCK";
    }
}

function resetCalibration() {
    localStorage.removeItem('px_cm');
    pxPerCm = null;
    calibSamples = [];
    state = 'SCAN';
    updateUI();
}

function onMeasureClick() {
    if (state === 'READY') {
        perform3DMeasurement();
        state = 'RESULT';
    } else {
        state = 'READY';
        lastResult = null;
    }
    updateUI();
}

function processFrame() {
    if (!isStreaming || video.videoWidth === 0) {
        requestAnimationFrame(processFrame);
        return;
    }

    if (state === 'RESULT' && lastResult) {
        ctx.putImageData(lastResult, 0, 0);
        requestAnimationFrame(processFrame);
        return;
    }

    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    let src = cv.imread(canvas);
    let gray = new cv.Mat();
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0);

    if (state === 'SCAN') {
        detectA4(gray, src);
    }

    cv.imshow('canvasOutput', src);
    src.delete(); gray.delete();
    requestAnimationFrame(processFrame);
}

function detectA4(gray, src) {
    let edged = new cv.Mat();
    cv.Canny(gray, edged, 50, 150);
    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(edged, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    for (let i = 0; i < contours.size(); ++i) {
        let cnt = contours.get(i);
        if (cv.contourArea(cnt) > 10000) {
            let approx = new cv.Mat();
            cv.approxPolyDP(cnt, approx, 0.02 * cv.arcLength(cnt, true), true);
            if (approx.rows === 4) {
                let pts = [];
                for(let j=0; j<4; j++) pts.push({x: approx.data32S[j*2], y: approx.data32S[j*2+1]});
                
                let d1 = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
                let d2 = Math.hypot(pts[1].x - pts[2].x, pts[1].y - pts[2].y);
                calibSamples.push(Math.max(d1, d2) / 29.7);

                progressFill.style.width = (calibSamples.length / REQUIRED_SAMPLES * 100) + "%";

                if (calibSamples.length >= REQUIRED_SAMPLES) {
                    pxPerCm = calibSamples.sort((a,b) => a-b)[20];
                    localStorage.setItem('px_cm', pxPerCm);
                    state = 'READY';
                    updateUI();
                }
            }
            approx.delete();
        }
    }
    edged.delete(); contours.delete(); hierarchy.delete();
}

function perform3DMeasurement() {
    let src = cv.imread(canvas);
    let gray = new cv.Mat();
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    cv.bilateralFilter(gray, gray, 9, 75, 75);
    let edged = new cv.Mat();
    cv.Canny(gray, edged, 50, 150);
    
    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(edged, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    let bestCnt = null;
    let maxArea = 0;
    for (let i = 0; i < contours.size(); ++i) {
        let area = cv.contourArea(contours.get(i));
        if (area > maxArea && area < (src.rows * src.cols * 0.8)) {
            maxArea = area;
            bestCnt = contours.get(i);
        }
    }

    if (bestCnt) {
        let hull = new cv.Mat();
        cv.convexHull(bestCnt, hull);
        let approx = new cv.Mat();
        cv.approxPolyDP(hull, approx, 0.02 * cv.arcLength(hull, true), true);
        
        analyzeBox3D(approx);
        
        hull.delete(); approx.delete();
    }
    
    lastResult = ctx.getImageData(0, 0, canvas.width, canvas.height);
    src.delete(); gray.delete(); edged.delete(); contours.delete(); hierarchy.delete();
}

function analyzeBox3D(approx) {
    let pts = [];
    for (let i = 0; i < approx.rows; i++) {
        pts.push({ x: approx.data32S[i*2], y: approx.data32S[i*2+1] });
    }

    let edges = [];
    pts.forEach((p1, i) => {
        let p2 = pts[(i + 1) % pts.length];
        let dx = p2.x - p1.x;
        let dy = p2.y - p1.y;
        let angle = Math.atan2(dy, dx) * 180 / Math.PI;
        // Normalisierung auf 0-180
        if (angle < 0) angle += 180;
        let dist = Math.hypot(dx, dy) / pxPerCm;
        
        edges.push({p1, p2, dist, angle});
    });

    // 1. HÃ–HE (Gelb): Winkel nahe 90Â° (vertikal im Bild)
    let hCandidates = edges.filter(e => e.angle > 70 && e.angle < 110);
    
    // 2. BREITE & LÃ„NGE (Blau & GrÃ¼n): Flachere Winkel
    let floorCandidates = edges.filter(e => e.angle <= 70 || e.angle >= 110);

    // Wir gruppieren Bodenkanten nach Ã¤hnlichem Winkel (ParallelitÃ¤t)
    floorCandidates.sort((a,b) => a.angle - b.angle);
    
    // Wir nehmen die zwei dominantesten Richtungen am Boden
    // Typischerweise weichen LÃ¤nge und Breite um ca. 60-90 Grad voneinander ab
    let groupA = [];
    let groupB = [];
    if (floorCandidates.length > 0) {
        let firstAngle = floorCandidates[0].angle;
        floorCandidates.forEach(e => {
            if (Math.abs(e.angle - firstAngle) < 25) groupA.push(e);
            else groupB.push(e);
        });
    }

    // Zeichnen der Ergebnisse
    // HÃ¶he
    if (hCandidates.length > 0) {
        let h = hCandidates.sort((a,b) => b.dist - a.dist)[0];
        draw3DLine(h.p1, h.p2, h.dist, "H", "#ffff00");
    }

    // LÃ¤nge & Breite (basierend auf den Gruppen)
    let finalL = groupA.length > 0 ? groupA.sort((a,b) => b.dist - a.dist)[0] : null;
    let finalB = groupB.length > 0 ? groupB.sort((a,b) => b.dist - a.dist)[0] : null;

    // Falls LÃ¤nge kÃ¼rzer als Breite, tauschen wir die Bezeichnungen fÃ¼r die Logik
    if (finalL && finalB) {
        if (finalL.dist < finalB.dist) {
            let temp = finalL; finalL = finalB; finalB = temp;
        }
        draw3DLine(finalL.p1, finalL.p2, finalL.dist, "L", "#00ff00");
        draw3DLine(finalB.p1, finalB.p2, finalB.dist, "B", "#007bff");
    } else if (finalL) {
         draw3DLine(finalL.p1, finalL.p2, finalL.dist, "L", "#00ff00");
    }
}

function draw3DLine(p1, p2, dist, label, color) {
    ctx.strokeStyle = color;
    ctx.lineWidth = 12;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.stroke();

    let mx = (p1.x + p2.x) / 2;
    let my = (p1.y + p2.y) / 2;
    ctx.fillStyle = "rgba(0,0,0,0.8)";
    ctx.font = "bold 26px Arial";
    let text = label + ": " + dist.toFixed(1) + " cm";
    let tw = ctx.measureText(text).width;
    ctx.fillRect(mx - tw/2 - 10, my - 25, tw + 20, 45);
    ctx.fillStyle = color;
    ctx.fillText(text, mx - tw/2, my + 10);
}

window.onload = () => {
    if (typeof cv !== 'undefined' && cv.Mat) onOpenCvReady();
    else cv['onRuntimeInitialized'] = onOpenCvReady;
};
</script>
</body>
</html>