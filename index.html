<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Parcel Master</title>
    <script async src="https://docs.opencv.org/4.5.4/opencv.js" type="text/javascript"></script>
    <style>
        body { margin: 0; background: #000; font-family: 'Segoe UI', sans-serif; overflow: hidden; color: white; -webkit-user-select: none; }
        #container { position: relative; width: 100vw; height: 100vh; }
        video { position: absolute; width: 100%; height: 100%; object-fit: cover; }
        canvas { position: absolute; width: 100%; height: 100%; object-fit: cover; z-index: 5; }
        
        #ui-top { position: absolute; top: 0; width: 100%; z-index: 10; background: rgba(0,0,0,0.6); padding: 15px 0; text-align: center; border-bottom: 2px solid #007bff; }
        .status { font-size: 1.1rem; font-weight: bold; letter-spacing: 1px; }
        .progress-bg { width: 80%; background: #333; height: 8px; margin: 10px auto; border-radius: 4px; overflow: hidden; }
        #progress-fill { width: 0%; height: 100%; background: #28a745; transition: width 0.2s; }
        
        .controls { position: absolute; bottom: 40px; width: 100%; z-index: 10; display: flex; flex-direction: column; align-items: center; gap: 15px; }
        button { padding: 18px 40px; font-size: 1.2rem; border-radius: 50px; border: none; font-weight: bold; color: white; box-shadow: 0 4px 15px rgba(0,0,0,0.5); }
        #btn-measure { background: #007bff; width: 70%; }
        #btn-reset { background: #dc3545; font-size: 0.9rem; padding: 10px 20px; }
        
        .overlay-instr { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); border: 2px dashed rgba(255,255,255,0.5); width: 60%; height: 40%; pointer-events: none; display: none; }
        #loading-screen { position: fixed; inset: 0; background: #111; display: flex; justify-content: center; align-items: center; z-index: 100; flex-direction: column; }
    </style>
</head>
<body>

<div id="loading-screen">
    <div style="font-size: 2rem; margin-bottom: 20px;">ðŸ“¦</div>
    <div>Lade Computer Vision...</div>
</div>

<div id="container">
    <video id="videoInput" playsinline></video>
    <canvas id="canvasOutput"></canvas>
    <div id="target-box" class="overlay-instr"></div>
</div>

<div id="ui-top">
    <div id="status" class="status">Initialisiere...</div>
    <div id="p-container" class="progress-bg">
        <div id="progress-fill"></div>
    </div>
</div>

<div class="controls">
    <button id="btn-measure" onclick="onMeasure()">FOTO & MESSEN</button>
    <button id="btn-reset" onclick="resetApp()">NEU KALIBRIEREN</button>
</div>

<script>
let state = 'SCAN'; // SCAN, READY, RESULT
let pxPerCm = localStorage.getItem('px_cm') ? parseFloat(localStorage.getItem('px_cm')) : null;
let calibData = [];
const SAMPLES_NEEDED = 80;

let video = document.getElementById('videoInput');
let canvas = document.getElementById('canvasOutput');
let ctx = canvas.getContext('2d');
let stream = null;
let resultFrame = null;

function onOpenCvReady() {
    document.getElementById('loading-screen').style.display = 'none';
    startApp();
}

async function startApp() {
    stream = await navigator.mediaDevices.getUserMedia({ 
        video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } } 
    });
    video.srcObject = stream;
    video.play();
    
    state = pxPerCm ? 'READY' : 'SCAN';
    updateUI();
    requestAnimationFrame(processFrame);
}

function updateUI() {
    const s = document.getElementById('status');
    const p = document.getElementById('p-container');
    const b = document.getElementById('btn-measure');
    const t = document.getElementById('target-box');

    if (state === 'SCAN') {
        s.innerText = "PHASE 1: BLATT ABSCANNEN (Bewegen!)";
        s.style.color = "#ffc107";
        p.style.display = "block";
        b.style.display = "none";
        t.style.display = "none";
    } else {
        s.innerText = state === 'READY' ? "PHASE 2: PAKET MESSBEREIT" : "ERGEBNIS";
        s.style.color = "#28a745";
        p.style.display = "none";
        b.style.display = "block";
        b.innerText = state === 'READY' ? "PAKET MESSEN" : "NEUE MESSUNG";
        t.style.display = state === 'READY' ? "block" : "none";
    }
}

function resetApp() {
    localStorage.removeItem('px_cm');
    pxPerCm = null;
    calibData = [];
    state = 'SCAN';
    resultFrame = null;
    updateUI();
}

function onMeasure() {
    if (state === 'READY') {
        state = 'RESULT';
    } else {
        state = 'READY';
        resultFrame = null;
    }
    updateUI();
}

function processFrame() {
    if (state === 'RESULT' && resultFrame) {
        ctx.putImageData(resultFrame, 0, 0);
        requestAnimationFrame(processFrame);
        return;
    }

    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    ctx.drawImage(video, 0, 0);

    let src = cv.imread(canvas);
    let gray = new cv.Mat();
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0);
    cv.Canny(gray, gray, 50, 150);

    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(gray, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    if (state === 'SCAN') {
        handleCalibration(contours, src);
    } else if (state === 'READY') {
        // Im Live-Bild nur eine Vorschau zeichnen
    } else if (state === 'RESULT' && !resultFrame) {
        runGrabCutAndMeasure(src);
    }

    src.delete(); gray.delete(); contours.delete(); hierarchy.delete();
    requestAnimationFrame(processFrame);
}

function handleCalibration(contours, src) {
    for (let i = 0; i < contours.size(); ++i) {
        let cnt = contours.get(i);
        if (cv.contourArea(cnt) > 10000) {
            let approx = new cv.Mat();
            cv.approxPolyDP(cnt, approx, 0.02 * cv.arcLength(cnt, true), true);
            if (approx.rows === 4) {
                drawCvRect(approx, [0, 255, 0, 255]);
                let d1 = Math.hypot(approx.data32S[0]-approx.data32S[2], approx.data32S[1]-approx.data32S[3]);
                let d2 = Math.hypot(approx.data32S[2]-approx.data32S[4], approx.data32S[3]-approx.data32S[5]);
                calibData.push(Math.max(d1, d2) / 29.7);
                
                let progress = (calibData.length / SAMPLES_NEEDED) * 100;
                document.getElementById('progress-fill').style.width = progress + "%";
                
                if (calibData.length >= SAMPLES_NEEDED) {
                    pxPerCm = calibData.sort((a,b) => a-b)[Math.floor(calibData.length/2)];
                    localStorage.setItem('px_cm', pxPerCm);
                    state = 'READY';
                    updateUI();
                }
            }
            approx.delete();
        }
    }
}

function runGrabCutAndMeasure(src) {
    // Einfache Segmentierung fÃ¼r den Browser-Prototyp
    // Wir extrahieren Konturen im Fokusbereich
    let gray = new cv.Mat();
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    cv.Canny(gray, gray, 50, 150);
    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(gray, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    let biggest = null;
    let maxArea = 0;
    for (let i = 0; i < contours.size(); ++i) {
        let area = cv.contourArea(contours.get(i));
        if (area > maxArea && area < (src.rows * src.cols * 0.8)) {
            maxArea = area;
            biggest = contours.get(i);
        }
    }

    if (biggest) {
        let hull = new cv.Mat();
        cv.convexHull(biggest, hull);
        let approx = new cv.Mat();
        cv.approxPolyDP(hull, approx, 0.02 * cv.arcLength(hull, true), true);
        
        drawResultGraphics(approx);
        
        hull.delete(); approx.delete();
    }
    
    resultFrame = ctx.getImageData(0, 0, canvas.width, canvas.height);
    gray.delete(); contours.delete(); hierarchy.delete();
}

function drawResultGraphics(approx) {
    let pts = [];
    for (let i = 0; i < approx.rows; i++) {
        pts.push({ x: approx.data32S[i*2], y: approx.data32S[i*2+1] });
    }

    // 3D Logik: Wir suchen vertikale (HÃ¶he) und horizontale (Boden) Kanten
    pts.forEach((p1, i) => {
        let p2 = pts[(i + 1) % pts.length];
        let dx = p2.x - p1.x;
        let dy = p2.y - p1.y;
        let angle = Math.abs(Math.atan2(dy, dx) * 180 / Math.PI);
        let dist = Math.hypot(dx, dy) / pxPerCm;

        let color = "#0f0"; // LÃ¤nge Standard
        let label = "L";

        if (angle > 70 && angle < 110) {
            color = "#ff0"; // HÃ¶he
            label = "H";
        } else if (dist < 15) { // Kleinerer Wert meist Breite
            color = "#00f";
            label = "B";
        }

        // Zeichnen
        ctx.strokeStyle = color;
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();

        // Label mit Hintergrund
        ctx.fillStyle = "black";
        ctx.fillRect((p1.x+p2.x)/2 - 30, (p1.y+p2.y)/2 - 20, 80, 30);
        ctx.fillStyle = color;
        ctx.font = "bold 20px Arial";
        ctx.fillText(`${label}: ${dist.toFixed(1)}cm`, (p1.x+p2.x)/2 - 25, (p1.y+p2.y)/2);
    });
}

function drawCvRect(approx, color) {
    ctx.strokeStyle = `rgba(${color[0]},${color[1]},${color[2]},1)`;
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.moveTo(approx.data32S[0], approx.data32S[1]);
    for (let i = 1; i < 4; i++) ctx.lineTo(approx.data32S[i*2], approx.data32S[i*2+1]);
    ctx.closePath();
    ctx.stroke();
}

window.onload = () => {
    if (typeof cv !== 'undefined' && cv.Mat) onOpenCvReady();
    else window.cv = { onRuntimeInitialized: onOpenCvReady };
};
</script>
</body>
</html>