<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Parcel Master Pro</title>
    <script async src="https://docs.opencv.org/4.5.4/opencv.js" type="text/javascript"></script>
    <style>
        body { margin: 0; background: #000; font-family: sans-serif; overflow: hidden; color: white; }
        #container { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
        video { position: absolute; width: 100%; height: 100%; object-fit: cover; opacity: 0; } /* Video unsichtbar, wir nutzen Canvas */
        canvas { position: absolute; width: 100%; height: 100%; object-fit: cover; z-index: 5; }
        
        #target-box { 
            position: absolute; width: 60%; height: 40%; 
            border: 4px dashed rgba(255, 255, 255, 0.8); 
            z-index: 10; pointer-events: none; display: none;
            box-shadow: 0 0 0 1000px rgba(0,0,0,0.4);
        }

        #ui-top { position: absolute; top: 0; width: 100%; z-index: 20; background: rgba(0,0,0,0.8); padding: 20px 0; text-align: center; }
        .status { font-size: 1.2rem; font-weight: bold; margin-bottom: 10px; }
        .progress-bg { width: 80%; background: #333; height: 12px; margin: 0 auto; border-radius: 6px; }
        #progress-fill { width: 0%; height: 100%; background: #28a745; border-radius: 6px; transition: width 0.2s; }
        
        .controls { position: absolute; bottom: 40px; width: 100%; z-index: 20; display: flex; flex-direction: column; align-items: center; gap: 15px; }
        button { padding: 20px 40px; font-size: 1.3rem; border-radius: 50px; border: none; font-weight: bold; color: white; cursor: pointer; }
        #btn-measure { background: #007bff; width: 70%; display: none; }
        #btn-reset { background: #444; font-size: 0.9rem; }

        #loading { position: fixed; inset: 0; background: #111; z-index: 100; display: flex; flex-direction: column; justify-content: center; align-items: center; }
    </style>
</head>
<body>

<div id="loading">
    <div style="font-size: 3rem;">ðŸ“¦</div>
    <p>KI-Module werden geladen...</p>
</div>

<div id="container">
    <video id="videoInput" playsinline muted></video>
    <canvas id="canvasOutput"></canvas>
    <div id="target-box"></div>
</div>

<div id="ui-top">
    <div id="status">Warte auf Kamera...</div>
    <div class="progress-bg" id="p-bar-container">
        <div id="progress-fill"></div>
    </div>
</div>

<div class="controls">
    <button id="btn-measure" onclick="onMeasureClick()">PAKET MESSEN</button>
    <button id="btn-reset" onclick="resetCalibration()">NEU KALIBRIEREN</button>
</div>

<script>
let state = 'SCAN';
let pxPerCm = localStorage.getItem('px_cm') ? parseFloat(localStorage.getItem('px_cm')) : null;
let calibSamples = [];
const REQUIRED_SAMPLES = 50;

const video = document.getElementById('videoInput');
const canvas = document.getElementById('canvasOutput');
const ctx = canvas.getContext('2d');
const targetBox = document.getElementById('target-box');
const statusText = document.getElementById('status');
const btnMeasure = document.getElementById('btn-measure');
const progressFill = document.getElementById('progress-fill');

let isStreaming = false;

function onOpenCvReady() {
    document.getElementById('loading').style.display = 'none';
    initCamera();
}

async function initCamera() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } } 
        });
        video.srcObject = stream;
        video.play();
        
        video.oncanplay = () => {
            if (!isStreaming) {
                isStreaming = true;
                state = pxPerCm ? 'READY' : 'SCAN';
                updateUI();
                processFrame();
            }
        };
    } catch (e) {
        alert("Kamerafehler: " + e.message);
    }
}

function updateUI() {
    if (state === 'SCAN') {
        statusText.innerText = "PHASE 1: BLATT ABSCANNEN";
        statusText.style.color = "#ffc107";
        targetBox.style.display = "none";
        btnMeasure.style.display = "none";
        document.getElementById('p-bar-container').style.display = "block";
    } else if (state === 'READY') {
        statusText.innerText = "PHASE 2: PAKET IN DEN RAHMEN";
        statusText.style.color = "#00ff00";
        targetBox.style.display = "block";
        btnMeasure.style.display = "block";
        btnMeasure.innerText = "PAKET MESSEN";
        document.getElementById('p-bar-container').style.display = "none";
    } else if (state === 'RESULT') {
        statusText.innerText = "ERGEBNIS";
        targetBox.style.display = "none";
        btnMeasure.innerText = "ZURÃœCK";
    }
}

function resetCalibration() {
    localStorage.removeItem('px_cm');
    pxPerCm = null;
    calibSamples = [];
    state = 'SCAN';
    updateUI();
}

function onMeasureClick() {
    if (state === 'READY') {
        performMeasurement();
        state = 'RESULT';
    } else {
        state = 'READY';
    }
    updateUI();
}

function processFrame() {
    // WICHTIG: PrÃ¼fen ob das Video wirklich Pixel liefert
    if (!isStreaming || video.videoWidth === 0 || state === 'RESULT') {
        requestAnimationFrame(processFrame);
        return;
    }

    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    try {
        let src = cv.imread(canvas);
        let gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0);

        if (state === 'SCAN') {
            detectCalibrationSheet(gray, src);
        }

        cv.imshow('canvasOutput', src);
        src.delete(); gray.delete();
    } catch (err) {
        console.log("Warte auf Bilddaten...");
    }

    requestAnimationFrame(processFrame);
}

function detectCalibrationSheet(gray, src) {
    let edged = new cv.Mat();
    cv.Canny(gray, edged, 50, 150);
    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(edged, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    for (let i = 0; i < contours.size(); ++i) {
        let cnt = contours.get(i);
        if (cv.contourArea(cnt) > 8000) {
            let approx = new cv.Mat();
            cv.approxPolyDP(cnt, approx, 0.02 * cv.arcLength(cnt, true), true);
            if (approx.rows === 4) {
                let pts = [];
                for(let j=0; j<4; j++) pts.push({x: approx.data32S[j*2], y: approx.data32S[j*2+1]});
                
                // Zeichnen des Referenz-Rahmens
                ctx.strokeStyle = "#00ff00";
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(pts[0].x, pts[0].y);
                for(let p of pts) ctx.lineTo(p.x, p.y);
                ctx.closePath();
                ctx.stroke();

                let d1 = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
                let d2 = Math.hypot(pts[1].x - pts[2].x, pts[1].y - pts[2].y);
                calibSamples.push(Math.max(d1, d2) / 29.7);

                let progress = (calibSamples.length / REQUIRED_SAMPLES) * 100;
                progressFill.style.width = progress + "%";

                if (calibSamples.length >= REQUIRED_SAMPLES) {
                    pxPerCm = calibSamples.sort((a,b) => a-b)[Math.floor(REQUIRED_SAMPLES/2)];
                    localStorage.setItem('px_cm', pxPerCm);
                    state = 'READY';
                    updateUI();
                }
            }
            approx.delete();
        }
    }
    edged.delete(); contours.delete(); hierarchy.delete();
}

function performMeasurement() {
    let src = cv.imread(canvas);
    let gray = new cv.Mat();
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    cv.Canny(gray, gray, 50, 150);
    
    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(gray, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    let bestCnt = null;
    let maxArea = 0;

    for (let i = 0; i < contours.size(); ++i) {
        let cnt = contours.get(i);
        let area = cv.contourArea(cnt);
        if (area > maxArea && area < (src.rows * src.cols * 0.7)) {
            maxArea = area;
            bestCnt = cnt;
        }
    }

    if (bestCnt) {
        let approx = new cv.Mat();
        let hull = new cv.Mat();
        cv.convexHull(bestCnt, hull);
        cv.approxPolyDP(hull, approx, 0.02 * cv.arcLength(hull, true), true);
        
        draw3DResults(approx);
        
        approx.delete(); hull.delete();
    }
    src.delete(); gray.delete(); contours.delete(); hierarchy.delete();
}

function draw3DResults(approx) {
    let pts = [];
    for (let i = 0; i < approx.rows; i++) {
        pts.push({ x: approx.data32S[i*2], y: approx.data32S[i*2+1] });
    }

    pts.forEach((p1, i) => {
        let p2 = pts[(i + 1) % pts.length];
        let dx = p2.x - p1.x;
        let dy = p2.y - p1.y;
        let dist = Math.hypot(dx, dy) / pxPerCm;
        let angle = Math.abs(Math.atan2(dy, dx) * 180 / Math.PI);

        let color = "#00ff00"; // L
        let label = "L";

        if (angle > 70 && angle < 110) {
            color = "#ffff00"; // H
            label = "H";
        } else if (dist < 20) {
            color = "#007bff"; // B
            label = "B";
        }

        ctx.strokeStyle = color;
        ctx.lineWidth = 10;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();

        ctx.fillStyle = "rgba(0,0,0,0.8)";
        ctx.fillRect((p1.x+p2.x)/2 - 45, (p1.y+p2.y)/2 - 35, 100, 45);
        ctx.fillStyle = color;
        ctx.font = "bold 26px Arial";
        ctx.fillText(`${label}: ${dist.toFixed(1)}cm`, (p1.x+p2.x)/2 - 40, (p1.y+p2.y)/2);
    });
}

window.onload = () => {
    if (typeof cv !== 'undefined' && cv.Mat) onOpenCvReady();
    else cv['onRuntimeInitialized'] = onOpenCvReady;
};
</script>
</body>
</html>